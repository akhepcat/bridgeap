#/bin/sh
PROG="${0##*/}"

## this code snippet is taken from Dan Dascalescu's response on
## http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
SOURCE="${BASH_SOURCE[0]}"
while [[ -h "$SOURCE" ]]
do
	# resolve $SOURCE until the file is no longer a symlink
	DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
	SOURCE="$(readlink "$SOURCE")"
	# if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
	[[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
PDIR="$( cd -P "$( dirname "$SOURCE" )" && pwd -P )"
## end

DO_RETURN=${SHLVL}
SED="sed --follow-symlinks -i"

do_exit()
{
        STATUS=${1:-0}
        REASON=${2}

        [[ -n "${REASON}" ]] && echo "${REASON}"

        [[ ${DO_RETURN} -eq 1 ]] && return $STATUS || exit $STATUS
}

unmanage_interface() {

	if [[ -s /etc/NetworkManager/NetworkManager.conf ]]
	then
	        UNMANAGED=$(fgrep unmanaged-devices /etc/NetworkManager/NetworkManager.conf)
		KEYFILE=$(fgrep "[keyfile]" /etc/NetworkManager/NetworkManager.conf)

		if [[ -z "${KEYFILE}" ]]
		then
			echo "[keyfile]" >> /etc/NetworkManager/NetworkManager.conf
			echo "unmanaged-devices=mac:${MAC}" >> /etc/NetworkManager/NetworkManager.conf

		elif [[ -z "$(fgrep ${MAC} /etc/NetworkManager/NetworkManager.conf)" ]]
		then
	                ${SED} "s/\(unmanaged-devices\)=.*/\1=mac:${MAC}/" /etc/NetworkManager/NetworkManager.conf
		else
			return
		fi

		# if we've touched anything, we need to restart NetworkManager
		service network-manager restart
	# ELSE NOOP
	fi
}

dhcpd_reconf() {
	if [[ -n "${BRIDGEAP_NET}" ]]
	then
		${SED} "s/^subnet.*netmask.*/subnet ${BRIDGEAP_NET} netmask 255.255.255.0 {/" ${BRIDGEAP_DHCP}
		${SED} "s/range.*/range ${BRIDGEAP_NET%0}5 ${BRIDGEAP_NET%0}250;/" ${BRIDGEAP_DHCP}
		${SED} "s/\(broadcast-address\).*/\1 ${BRIDGEAP_NET%0}255;/" ${BRIDGEAP_DHCP}
		${SED} "s/routers.*/routers ${BRIDGEAP_NET%0}1;/" ${BRIDGEAP_DHCP}
		${SED} "s/\(fixed-address\).*/\1 ${BRIDGEAP_NET%0}1;/" ${BRIDGEAP_DHCP}
	fi
	[[ -n "${DNS_IPS}" ]] && ${SED} "s/\(domain-name-servers\).*/\1 ${DNS_IPS};/" ${BRIDGEAP_DHCP}
	[[ -n "${MAC}" ]] && ${SED} "s/\(ethernet\).*/\1 ${MAC};/" ${BRIDGEAP_DHCP}

}

hostapd_reconf() {
	[[ -n "${WPA_CHANNEL}" ]] && ${SED} "s/\(channel\)=.*/\1=${WPA_CHANNEL}/" ${BRIDGEAP_CONF}
	[[ -n "${WPA_PASS}" ]] && ${SED} "s/\(wpa_passphrase\)=.*/\1=${WPA_PASS}/" ${BRIDGEAP_CONF}
	[[ -n "${SSID}" ]] && ${SED} "s/\(ssid\)=.*/\1=${SSID}/" ${BRIDGEAP_CONF}
}

#############################

start() {
	[[ "${INSIDE}" = "${OUTSIDE}" ]] && do_exit 1 "Conflicting interface configuration"

        dhcpd_reconf

        if [ -n "${WIFI}" -a -z "$( pgrep -f ${BRIDGEAP_CONF##*/} )" ]
        then
                unmanage_interface
                hostapd_reconf

                # update the config for the 'current' wifi interface
                ${SED} "s/interface=wlan.*/interface=${WIFI}/" ${BRIDGEAP_CONF}
		ifconfig ${WIFI} up
                if [[ ${IGNORE_MODE:-0} -eq 0 ]]
		then
			iwconfig ${WIFI} mode Master || do_exit 1 "failed to set Master mode"
		fi
                [[ -x /usr/sbin/hostapd ]] && /usr/sbin/hostapd -B ${BRIDGEAP_CONF} 2>/dev/null || do_exit 1 "Failed to start hostapd on interface ${WIFI}, aborting"
	else
	        ip link set dev ${INSIDE} up
        fi

        ip -4 addr add dev ${INSIDE} ${BRIDGEAP_NET%0}1/24 broadcast ${BRIDGEAP_NET%0}255

        [[ -r ${BRIDGEAP_LEASES} ]] || touch ${BRIDGEAP_LEASES}

	DHCP_VER=$( test -x /usr/sbin/dhcpd && /usr/sbin/dhcpd -h 2>&1 | head -1 | sed 's/[a-z .]//ig')

	[[ -z "${DHCP_VER}" ]] && do_exit 1 "Failed to locate dhcpd"

	if [[ ${DHCP_VER} -gt 422 ]]
	then
		DUSER="-user ${DHCP_USER}"
		DGROUP="-group ${DHCP_GROUP}"
	fi

        [[ -z "$( pgrep -f \"dhcpd.*${INSIDE}\" )" ]] &&  \
		/usr/sbin/dhcpd  \
			-4 ${DUSER} ${DGROUP} \
			-cf ${BRIDGEAP_DHCP} -lf ${BRIDGEAP_LEASES} \
			-pf ${BRIDGEAP_DHCP_PIDF} ${INSIDE}

	[[ $? -eq 0 ]] || do_exit 1 "dhcp server failed to start"

	iptables -A FORWARD -i ${INSIDE} -o ${OUTSIDE} -m conntrack --ctstate NEW -j ACCEPT
	iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
	iptables -t nat -A POSTROUTING -s ${BRIDGEAP_NET}/24 -o ${OUTSIDE} -j MASQUERADE

	echo 1 >/proc/sys/net/ipv4/conf/all/forwarding
}

stop() {
	echo 0 >/proc/sys/net/ipv4/conf/all/forwarding

        iptables -D FORWARD -i ${INSIDE} -o ${OUTSIDE} -m conntrack --ctstate NEW -j ACCEPT
        iptables -D FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
        iptables -t nat -D POSTROUTING -s ${BRIDGEAP_NET}/24 -o ${OUTSIDE} -j MASQUERADE

	PID=$( pgrep -f ${BRIDGEAP_CONF##*/} )
	[[ -n "${PID}" ]] && kill -9 ${PID}

	PID=$( pgrep -f "dhcpd.*${INSIDE}" )
	[[ -n "${PID}" ]] && kill -9 ${PID}

	if [[ ${IGNORE_MODE:-0} -eq 0 ]]
	then
		[[ -n "${WIFI}" ]] && iwconfig ${WIFI} mode Managed
	fi
	ifconfig ${INSIDE} 0.0.0.0 down
}

check_outside() {
	ROUTE="$(ip -4 route show default scope global | grep -v "dev[[:space:]]*br" )" # ignore bridges
	DEFROUTE=${ROUTE##*dev }
	OUTSIDE=${DEFROUTE%% *}
}

################################

if [[ -r "/etc/bridgeap/bridgeap.conf" ]]
then
        . /etc/bridgeap/bridgeap.conf

elif [[ -r "/etc/bridgeap.conf" ]]
then
        . /etc/bridgeap.conf

elif [[ -r "${PDIR}/bridgeap.conf" ]]
then
        . ${PDIR}/bridgeap.conf
else
        do_exit 1 "You must create a bridgeap.conf file in ${PDIR}, /etc/, or /etc/bridgeap/"
fi

check_outside

if [[ ${SPIN_UNTIL_UP} -ge 2 ]]
then
	if [[ -z "${OUTSIDE}" ]]
	then
		sleep ${SPIN_UNTIL_UP}
		check_outside
	fi
elif [[ ${SPIN_UNTIL_UP} -eq 1 ]]
then
	# loop forever until we're up!  Check every 5 seconds...
	while [[ -z "${OUTSIDE}" ]]
	do
		sleep 5
		check_outside
	done
# else
#	no-op
fi

[[ -z "${OUTSIDE}" ]] && do_exit 1 "No network connectivity, aborting"

# First look for any WiFi interfaces...
WIFIS=$(iwconfig 2>&1| grep -v extensions | grep '^[a-z0-9]' | awk '{print $1}' | grep -v ${OUTSIDE} )

[[ 1 -eq ${AVOID_DOWN:-0} ]] && AVOID_DOWN="NO.CARRIER|"
ETHS="$(ip link show | grep -vE "${AVOID_DOWN}master" | grep -E '\d*:[[:space:]]*eth' | cut -f 2 -d: | awk '{print $1}' | grep -v ${OUTSIDE} | head -1 )"	# ignore the OUTSIDE interface, but list all others


# automagically decide if we're wifi->wifi, wifi->eth, or eth->wifi, as much as possible, ignoring bridges
ROUTED_IFS="$(ip route show scope link | grep -v ${OUTSIDE} | sed 's/^.*dev[[:space:]]*\([a-z0-9]*\)[[:space:]]*.*$/\1/g' | sort -u)"  # get a list of internal interfaces with active routes

for RIF in ${ROUTED_IFS}
do
	# remove any interfaces that match an active routing interface
	WIFIS="${WIFIS//$RIF}"
	ETHS="${ETHS//$RIF}"
done
NUM_WIFIS=( ${WIFIS} )
NUM_WIFIS=${#NUM_WIFIS[@]}
NUM_ETHS=( ${ETHS} )
NUM_ETHS=${#NUM_ETHS[@]}

if [ ${NUM_WIFIS} -eq 0 -a ${NUM_ETHS} -eq 0 ]
then
	do_exit 1 "no internal interface available, aborting"
fi

if [ ${NUM_WIFIS} -gt 0 -a ${NUM_ETHS} -gt 0 ]
then
	do_exit 1 "both wifi and eth are available, can't auto-decide. aborting"
fi

[[ ${NUM_WIFIS} -gt 1 ]] && do_exit 1 "Too many available WIFI interfaces for automagic determination"
[[ ${NUM_ETHS} -gt 1 ]] && do_exit 1 "Too many available ETH interfaces for automagic determination"

WIFI=${WIFIS}
INSIDE="${WIFI}${ETHS}"

MAC="$(ip link show ${INSIDE} | grep ether | awk '{print $2}')"

case $1 in
        start) start
                ;;
        stop) stop
                ;;
        restart|reload) stop; sleep 2; start
                ;;
        *)
echo "usage: ${PROG} [start|stop|restart|reload" ;
echo -e "\t\t bridges outside (${OUTSIDE}) to inside (${INSIDE})";
                ;;
esac

do_exit

